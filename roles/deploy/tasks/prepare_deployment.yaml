# testing examples: '\{\"limit_application\":[\"x\",\"y\"]}'  '\{\"limit_application\":\"x1y\"}' '{"limit_application":[infopage,tor],"limit_namespace":[tools]}' '{"limit_application":[1a1],"limit_namespace":[ns2]}'
- block:
  - set_fact:
      apps: "{{ applications }}"
      net: "{{ net }}"
      
# add istio gateways as application to list of applications
  - name: combine gateway deployment into applications # all raw items have to be treated before! # merge from gateway_install + optional additional_ports on individual gateway
    set_fact:
      apps: |
        {%- set domain_list = [item.domain] -%}
        {%- if item.endpointIP is defined -%}
        {%- set _d = domain_list.append(net.domain_external) -%}
        {%- endif -%}
        {{ apps | combine( {default_gateway_namespace: {item.domain|replace('.','-'): gateway_install | combine(
                     {'network':{ 
                          'endpointIP': item.endpointIP,
                          'hosts': domain_list,
                          'domain': item.domain
                     }})
        }}, recursive=true)}}
    loop: "{{ net.routes | selectattr('gateway','equalto','istio') }}"# | map(attribute='domain') | list}}"

  - name: application list with Istio gateways added
    debug:
      msg: 'apps: {{ apps | to_yaml }}'
    when: "'debug' in ansible_run_tags"
    failed_when: false

# flatten apps to app_list making namespace an attribute
  - debug: 
      msg: "{{item.key}}: {{ item.value }}\n{{ names | zip(item.value| dict2items| map(attribute='value') ) | to_nice_yaml }}" # create array from names and application values
    vars:
      app_name: "{{ item.value | dict2items | map(attribute='key') }}"   # get application name
      names: "{{ (app_name) | zip(([item.key]*(app_name|length))   ) }}" # create array of application and namespace name
    loop: "{{ apps |dict2items}}"

  - name: flatten app list - add arrays of namespace and application name to each application dict
    set_fact:
      app_temp: "{{ app_temp | default([]) + (names | zip(item.value| dict2items| map(attribute='value') )) }}" # create array from names and application values
    vars:
      app_name: "{{ item.value | dict2items | map(attribute='key') }}"   # get application name 
      names: "{{ (app_name) | zip(([item.key]*(app_name|length))   ) }}" # create array of application and namespace name
    loop: "{{ apps |dict2items}}"

  - name: flatten app list - transform temporary array values of namespace and application name into dict items
    vars:
      y: "{{ {'namespace':item[0][1],'name':item[0][0]} | combine(item[1]) }}" # turn names array item[0] into dict
    set_fact:
      app_list: "{{ (app_list|default([])) + [y] }}"
    loop: "{{ app_temp }}"

# apply defaults and requirements
  - name: apply defaults and requirements
    vars:
      my_idx: "{{ app_list | ansible.utils.index_of('eq', app.name, 'name') }}"
      rq: "{{ app.requires|default([])+[{'name': app.network.domain|default(base_domain)|replace('.','-'),'namespace': default_gateway_namespace, 'type': 'gateway' }] }}"
      # network_defaults is assigned in each loop to have new random values
      network_defaults: 
        rewrite: "/"
        svcPort: "{{ 65536|random(1024) }}"
        svcName: "{{ app.name }}"
        prefix: "{{ '/'~app.name}}"
        domain: "{{ base_domain }}"
        hosts: |
          {%- set domain_list = [app.network.domain|default(base_domain)] -%}
          {%- if app.network.endpointIP is defined -%}
          {%- set _d = domain_list.append(net.domain_external) -%}
          {%- endif -%}
          {{ domain_list }}
      networkAsDict: "{{ (app.network is boolean) | ternary({}, app.network) }}"
      network: "{{ network_defaults | combine(networkAsDict, recursive=true) }}"
      new_entry: "{{app  | combine({'requires': rq, 'network': network }, recursive=true) }}"
    set_fact:
      app_list: "{%- set _ = app_list.pop(my_idx|int) %}{{app_list+[new_entry]}}" # replace existing appliation list item by new_entry
    loop: "{{ app_list | selectattr('network', 'defined')  }}"
    loop_control:
      loop_var: app
    # failed_when: true

## build only_apps list from limit_application and limit_namespace variables
  - name: assign limit_namespace to fact
    set_fact:
      only_ns: "{{ limit_namespace }}"
    when: limit_namespace is defined

  - name: assign limit_application to fact
    set_fact:
      only_apps: "{{ limit_application }}"
    when: limit_application is defined

  - set_fact:
      only_apps: "{{[only_apps,]}}"
    when: only_apps is string
    
  - set_fact:
      only_ns: "{{[only_ns,]}}"
    when: only_ns is string

    # if namespace limitation given, add all applications of the namespace(s) to the list of limited applications
  - name: apps from limit_namespace
    block:
    - debug: 
       msg: "{{ item }}: apps: {{ app_list | selectattr('namespace', 'eq', item)| map(attribute='name') }}"
      loop: "{{ only_ns }}"
    - set_fact:
        only_apps: "{{ (only_apps|default([])) + app_list | selectattr('namespace', 'eq', item)| map(attribute='name') }}"
      loop: "{{ only_ns }}"
    when: only_ns is defined

  - debug:
      msg: "only_apps prepared:{{ only_apps }}"
    when: only_apps is defined

# combine all multi-level requirements to requires
  - name: debug - recursive requirements
    vars:
      my_idx: "{{ app_list | ansible.utils.index_of('eq', app.name, 'name') }}"
      app_deps: |
        {%- set loop_data={"reqs":[app.name],"app_list": app_list, 'all_req': []} -%}
        {# length: {{ loop_data.reqs|length }} loop_data: {{ loop_data}}  #}
        {%- for b in range(0,1000,1)  if (loop_data.reqs|length|int > 0) %} 
        {%- set current=loop_data.reqs.pop() %}
        {%- set req =     ((app_list | selectattr('name','eq',current)|list)[0]['requires'])  | default([])  | map(attribute='name' )| list %}
        {%- set full_req = (app_list | selectattr('name','eq',current)|list)[0]['requires'] | default([]) %}
        {%-  set update_reqs_for_loops_with_more_apps = loop_data.update( {'reqs':  loop_data.reqs + req    } ) %}
        {%-  set update_reqs_for_current_application = loop_data.update( {'all_req':  (loop_data.all_req + full_req) | unique     } ) %}
        {# current:{{current}} reqs left: {{loop_data.reqs}} req: {{ req }} all_req: {{ loop_data.all_req  }} #}
        {%- endfor %}
        {{ loop_data.all_req }} 
      new_app: "{{ app | ansible.utils.remove_keys(target=['requires'])| combine({'requires': app_deps}) }}"
    debug: 
      msg: "my_idx:{{ my_idx }}\napp_deps:{{app_deps}}\nnew_app:{{new_app}}"
    loop: "{{ app_list | selectattr('requires', 'defined')  }}"
    loop_control:
      loop_var: app

  - name: set - recursive requirements
    vars:
      my_idx: "{{ app_list | ansible.utils.index_of('eq', app.name, 'name') }}"
      app_deps: |
        {%- set loop_data={"reqs":[app.name],"app_list": app_list, 'all_req': []} -%}
        {# length: {{ loop_data.reqs|length }} loop_data: {{ loop_data}}  #}
        {%- for b in range(0,1000,1)  if (loop_data.reqs|length|int > 0) %} 
        {%-   set current=loop_data.reqs.pop() %}
        {%-   set full_req = (app_list | selectattr('name','eq',current)|list)[0]['requires'] | default([]) %}
        {%-   set req = (full_req | map(attribute='name' )| list) %}
        {%-   set update_reqs_for_loops_with_more_apps = loop_data.update( {'reqs':  loop_data.reqs + req    } ) %}
        {%-   set update_reqs_for_current_application = loop_data.update( {'all_req':  (loop_data.all_req + full_req) | unique     } ) %}
        {%- endfor %}
        {{ loop_data.all_req }} 
      new_app: "{{ app | ansible.utils.remove_keys(target=['requires']) | combine({'requires': app_deps}) }}"
    set_fact: 
      app_list: "{%- set _ = app_list.pop(my_idx|int) %}{{app_list+[new_app]}}" # replace existing appliation list item by new_entry
    loop: "{{ app_list | selectattr('requires', 'defined')  }}"  # process only those applications which have requirements set
    loop_control:
      loop_var: app

  - name: app_list
    debug: 
      msg: "app_list:\n{{ app_list | to_nice_yaml }}"

# extend only_apps with dependencies from requires attributes
  - block: 
    - name: debug - addition of dependencies to limited application list
      vars:
        add_reqs: "{{ (app_list | selectattr('name', 'eq', item) | selectattr('requires', 'defined') | map(attribute='requires'))[0]|default([]) |map(attribute='name' )|default([])  | list }}" 
      debug:
        msg: "reqs: \n{{ add_reqs }}"
      loop: "{{ only_apps }}"

    - name: determine additional applications for limited application list from dependencies
      vars:
        add_reqs: "{{ (app_list | selectattr('name', 'eq', item) | selectattr('requires', 'defined') | map(attribute='requires'))[0]|default([]) |map(attribute='name' )|default([])  | list }}" 
      set_fact:
        reqs: "{{ reqs|default([]) + add_reqs }}"
      loop: "{{ only_apps }}"

    - name: update additional applications for limited application list from dependencies
      set_fact:
        only_apps: "{{ (reqs + only_apps) | unique }}"
    when: "'deps' in ansible_run_tags and only_apps is defined" 

# set only_apps to all apps if not yet defined
  - name: set only_apps to include all_apps if only_apps is not defined
    set_fact:
      only_apps: "{{ app_list | map(attribute='name') | list }}"
    when: only_apps is not defined
 
  - name: turn app_list into a dict again
    set_fact:
      applications: >-
        {%- set apps = {} -%}
        {%- for item in app_list if item.name in only_apps -%}
        {%-   set ns = item.namespace -%}
        {%-   set nm = item.name -%}
        {%-   set attrs = {} -%}
        {%-   for k, v in item.items() if k not in ['namespace', 'name'] -%}
        {%-     set _ = attrs.update({k: v}) -%}
        {%-   endfor -%}
        {%-   if ns not in apps -%}
        {%-     set _ = apps.update({ns: {}}) -%}
        {%-   endif -%}
        {%-   set _ = apps[ns].update({nm: attrs}) -%}
        {%- endfor -%}
        {{ apps }}

  - name: remove items which are not required
    set_fact:
      appOOlications: >-
        {{
          (applications|default({})) | combine({ item.key: item.value | dict2items | selectattr('key', 'in', only_apps) | items2dict })
        }}
    loop: "{{ apps | dict2items }}"
    loop_control:
      loop_var: item
      
  - debug:
      msg: "applications:\n{{ applications | to_nice_yaml}}"
    failed_when: "'prepare' in ansible_run_tags"
  run_once: true
