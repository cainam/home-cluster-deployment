# testing examples: '\{\"limit_application\":[\"x\",\"y\"]}'  '\{\"limit_application\":\"x1y\"}' '{"limit_application":[infopage,tor],"limit_namespace":[tools]}' '{"limit_application":[1a1],"limit_namespace":[ns2]}'
- block:
  - set_fact:
      apps: "{{ applications }}"
      net_routes: []

  - name: add missing namespaces to net.routes
    set_fact:
      net_routes: >-
        {{
          net_routes+
          [
            item | combine({
              'namespace': item.namespace
                if item.namespace is defined
                else (
                  apps
                  | dict2items
                  | selectattr('value', 'defined')
                  | selectattr('value', 'contains', item.gateway)
                  | map(attribute='key')
                  | first
                )
            })
          ]
        }}
    loop: "{{ net.routes }}"
  
  - name: replace net.routes with normalized routes
    set_fact:
      net: "{{ net | combine({'routes': net_routes}, recursive=True) }}"
      
# add istio gateways as application to list of applications
  - name: combine istio gateway deployment into applications # all raw items have to be treated before! # merge from gateway_install + optional additional_ports on individual gateway
    set_fact:
      apps: |
        {%- set domain_list = [item.domain] -%}
        {%- if item.endpointIP is defined -%}
        {%- set _d = domain_list.append(net.domain_external) -%}
        {%- endif -%}
        {{ apps | combine( {item.namespace: {item.domain|replace('.','-'): gateway_install | combine(
                     {'network':{ 
                          'hosts': domain_list,
                          'domain': item.domain
                     }})
        }}, recursive=true)}}
    loop: "{{ net.routes | selectattr('gateway','equalto','istio') }}"

  - name: application list with Istio gateways added
    debug:
      msg: 'apps: {{ apps | to_yaml }}'
    when: "'debug' in ansible_run_tags"
    failed_when: false

# flatten apps to app_list making namespace an attribute
  - debug: 
      msg: "{{item.key}}: {{ item.value }}\n{{ names | zip(item.value| dict2items| map(attribute='value') ) | to_nice_yaml }}" # create array from names and application values
    vars:
      app_name: "{{ item.value | dict2items | map(attribute='key') }}"   # get application name
      names: "{{ (app_name) | zip(([item.key]*(app_name|length))   ) }}" # create array of application and namespace name
    loop: "{{ apps |dict2items}}"

  - name: flatten app list - add arrays of namespace and application name to each application dict
    set_fact:
      app_temp: "{{ app_temp | default([]) + (names | zip(item.value| dict2items| map(attribute='value') )) }}" # create array from names and application values
    vars:
      app_name: "{{ item.value | dict2items | map(attribute='key') }}"   # get application name 
      names: "{{ (app_name) | zip(([item.key]*(app_name|length))   ) }}" # create array of application and namespace name
    loop: "{{ apps |dict2items}}"

  - name: flatten app list - transform temporary array values of namespace and application name into dict items
    vars:
      y: "{{ {'namespace':item[0][1],'name':item[0][0]} | combine(item[1]) }}" # turn names array item[0] into dict
    set_fact:
      app_list: "{{ (app_list|default([])) + [y] }}"
    loop: "{{ app_temp }}"

# apply defaults and requirements
  - name: prepare lists for defaults and requirements treatment
    set_fact:
      org_list: "{{ app_list }}"
      app_list: "{{ [] }}"
  - name: apply defaults and requirements
    vars:
      my_dom: "{{ app.network.domain|default(net.base_domain) }}"
      my_route: "{{ net.routes | selectattr('domain','equalto',my_dom)|first }}"
      my_gw_rq: >-
        {{
         { 'name': my_dom | replace('.', '-'),
         'type': 'gateway',
         'namespace': my_route.namespace
         } }}
      rq: "{{ (app.requires|default([])|list)+[my_gw_rq] }}"
      # network_defaults is assigned in each loop to have new random values
      security:
        runAsUser: "{{ applicationSecurity[app.name].runAsUser | default(2147483647|random(65536)) }}"
        runAsGroup: "{{ applicationSecurity[app.name].runAsUser | default(2147483647|random(65536)) }}"
        directoryMode: "{{ applicationSecurity[app.name].directoryMode | default('u=rwx,g=-rwx,o=-rwx') }}"
        fileMode: "{{ applicationSecurity[app.name].fileMode| default('600') }}"
      network_defaults:
        rewrite: "/"
        svcPort: "{{ 65536|random(1024) }}"
        podPort: "{{ 65536|random(1024) }}"
        svcName: "{{ app.name }}"
        prefix: "{{ '/'~app.name}}"
        domain: "{{ my_dom  }}"
        publish: "{{ (app.network is defined and app.network is boolean and app.network) or (app.network is defined and app.network is not boolean) | bool }}"
        hosts: |
          {%- set domain_list = [my_dom] -%}
          {%- if my_route.endpointIP is defined -%}
          {%- set _d = domain_list.append(net.domain_external) -%}
          {%- endif -%}
          {{ domain_list }}
      networkAsDict: "{{ (app.network is defined and app.network is boolean) | ternary({}, (app.network if app.network is defined else {})) }}"
      network: "{{ network_defaults | combine(networkAsDict, recursive=true) }}"
      new_entry: "{{app  | combine({'requires': rq, 'network': network, 'security': security, 'flags': app.flags|default([]) }, recursive=true) }}"
    set_fact:
      app_list: "{{ app_list+[new_entry] }}"
    loop: "{{ org_list }}"
    loop_control:
      loop_var: app

## build only_apps list from limit_application and limit_namespace variables
  - name: assign limit_namespace to fact
    set_fact:
      only_ns: "{{ limit_namespace }}"
    when: limit_namespace is defined

  - name: assign limit_application to fact
    set_fact:
      only_apps: "{{ limit_application }}"
    when: limit_application is defined

  - set_fact:
      only_apps: "{{[only_apps,]}}"
    when: only_apps is defined and only_apps is string
    
  - set_fact:
      only_ns: "{{[only_ns,]}}"
    when: only_ns is defined and only_ns is string

    # if namespace limitation given, add all applications of the namespace(s) to the list of limited applications
  - name: apps from limit_namespace
    block:
    - debug: 
       msg: "{{ item }}: apps: {{ app_list | selectattr('namespace', 'eq', item)| map(attribute='name') }}"
      loop: "{{ only_ns }}"
    - set_fact:
        only_apps: "{{ (only_apps|default([])) + app_list | selectattr('namespace', 'eq', item)| map(attribute='name') }}"
      loop: "{{ only_ns }}"
    when: only_ns is defined

  - debug:
      msg: "only_apps prepared:{{ only_apps }}"
    when: only_apps is defined

# combine all multi-level requirements to requires
  - name: merge application requirements
    set_fact:
      app_list: >-
        {%- set loop_data={'all_apps': [], 'all_reqs': []} -%}
        {%- for app in app_list -%}
          {%- set reqs = [app.name] -%}
          {%- set _ = loop_data.update( {'all_reqs': [] }) -%}
          {%- for b in range(0,4,1)  if (reqs|length|int > 0) -%}
            {%- set current=reqs[-1] %}
            {%- set reqs=reqs[:-1] %}
            {%- set full_req = (app_list | selectattr('name','eq',current)|list)[0]['requires'] | default([]) -%}
            {%- set _ = loop_data.update( {'all_reqs': (loop_data.all_reqs+full_req) } ) %}
            {%- for r in full_req -%}
              {%- set _ = reqs.append(r.name) -%}
            {%- endfor -%}
          {%- endfor -%}
          {%- set new_app = app | combine({'requires': loop_data.all_reqs|unique}) -%}
          {%- set _ = loop_data.update( {'all_apps': (loop_data.all_apps+[new_app]) } ) %}
          {%- set _ = resolved.append(new_app) -%}
        {%- endfor -%}
        {{ loop_data.all_apps|unique }}

  - name: app_list
    debug: 
      msg: "app_list:\n{{ app_list | to_nice_yaml }}"

# extend only_apps with dependencies from requires attributes
  - block: 
    - name: debug - addition of dependencies to limited application list
      vars:
        add_reqs: "{{ (app_list | selectattr('name', 'eq', item) | selectattr('requires', 'defined') | map(attribute='requires'))[0]|default([]) |map(attribute='name' )|default([])  | list }}" 
      debug:
        msg: "reqs: \n{{ add_reqs }}"
      loop: "{{ only_apps }}"

    - name: determine additional applications for limited application list from dependencies
      vars:
        add_reqs: "{{ (app_list | selectattr('name', 'eq', item) | selectattr('requires', 'defined') | map(attribute='requires'))[0]|default([]) |map(attribute='name' )|default([])  | list }}" 
      set_fact:
        reqs: "{{ reqs|default([]) + add_reqs }}"
      loop: "{{ only_apps }}"

    - name: update additional applications for limited application list from dependencies
      set_fact:
        only_apps: "{{ (reqs + only_apps) | unique }}"
    when: "'deps' in ansible_run_tags and only_apps is defined" 

# set only_apps to all apps if not yet defined
  - name: set only_apps to include all_apps if only_apps is not defined
    set_fact:
      only_apps: "{{ app_list | map(attribute='name') | list }}"
    when: only_apps is not defined
 
  - name: turn app_list into a dict again
    set_fact:
      applications: >-
        {%- set apps = {} -%}
        {%- for item in app_list if item.name in only_apps -%}
        {%-   set ns = item.namespace -%}
        {%-   set nm = item.name -%}
        {%-   set attrs = {} -%}
        {%-   for k, v in item.items() if k not in ['namespace', 'name'] -%}
        {%-     set _ = attrs.update({k: v}) -%}
        {%-   endfor -%}
        {%-   if ns not in apps -%}
        {%-     set _ = apps.update({ns: {}}) -%}
        {%-   endif -%}
        {%-   set _ = apps[ns].update({nm: attrs}) -%}
        {%- endfor -%}
        {{ apps }}

  - name: remove items which are not required
    set_fact:
      appOOlications: >-
        {{
          (applications|default({})) | combine({ item.key: item.value | dict2items | selectattr('key', 'in', only_apps) | items2dict })
        }}
    loop: "{{ apps | dict2items }}"
    loop_control:
      loop_var: item
      
  - debug:
      msg: "applications:\n{{ applications | to_nice_yaml}}"
    failed_when: "'prepare' in ansible_run_tags"
#  run_once: true
