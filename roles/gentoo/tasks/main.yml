---

- name: groups
  group:
    name: "{{ item.name }}"
    gid: "{{ item.gid }}"
  loop:
    - name: k8s-prometheus
      gid: 100100
    - name: k8s-keycloak
      gid: 100200

- name: users
  user: 
    create_home: false
    name: "{{ item.name }}"
    group: "{{ item.group }}"
    uid: "{{ item.uid }}"
  loop:
    - name: k8s-prometheus
      uid: 100100
      group: k8s-prometheus
    - name: k8s-keycloak
      uid: 100200
      group: k8s-keycloak

- name: ensure required directories exist
  file:
    path: "{{ item.path }}"
    state: directory
    mode: "{{ item.perm }}"
  loop:
    - path: /etc/modprobe.d
      perm: u=rwx,g=rx,o=rx
    - path: /etc/wpa_supplicant
      perm: u=rwx,g=rx,o=rx
    - path: "{{ shared_mounts }}"
      perm: u=rwx,g=rx,o=rx
    - path: /etc/modules-load.d
      perm: u=rwx,g=rx,o=rx
    - path: /usr/local/share/ca-certificates/
      perm: u=rwx,g=rx,o=rx
    - path: "{{ gluster_directory }}/bricks"
      perm: u=rwx,g=rx,o=rx
    - path: /etc/autofs
      perm: u=rwx,g=rx,o=rx
    - path: /var/lib/iwd
      perm: u=rwx,g=rx,o=rx
    - path: /etc/iwd
      perm: u=rwx,g=rx,o=rx
    - path: /etc/cron.hourly
      perm: u=rwx,g=rx

- name: auto.master
  lineinfile: 
    path: /etc/autofs/auto.master
    regexp: "^{{ shared_mounts }}"
    line: "{{ shared_mounts }} /etc/autofs/gluster.autofs"
    backup: yes
    create: true

- name: symlinks for CA
  copy:
    src: "{{ cert_path }}/{{ item }}"
    dest: "{{ system_local_certs }}/{{ item }}"
    owner: root
    group: root
  register: ca
  loop: "{{ local_ca_files }}"

- name: update CA certificates
  shell: /usr/sbin/update-ca-certificates
  when: ca.changed

- name: rc.conf
  lineinfile:
    path: /etc/rc.conf
    regexp: "^{{ item.setting }}"
    line: "{{ item.line }}"
    insertafter: "{{ item.setting }}"
    backup: yes
  loop:
    - line: 'rc_logger="YES" # write rc logs to /var/log/rc.log, otherwise boot logs are lost'
      setting: rc_logger
    - line: 'rc_verbose="yes" # be verbose'
      setting: rc_verbose

- name: hostname in /etc/conf.d
  lineinfile:
    path: "/etc/conf.d/{{ item.file }}"
    regexp: "^{{ item.setting }}"
    line: "hostname=\"{{ item.line }}\""
    backup: yes
  loop:
    - line: "{{ ansible_facts['fqdn']  }}"
      setting: hostname
      file: hostname

- name: deploy from files
  synchronize:
    src: "{{ role_path }}/files/./"
    dest: "/"
    archive: yes
    recursive: yes
    rsync_opts:
      - "--relative"

- name: include secrets (wlan, ssh_keys)
  include_vars: "{{ local_only }}/secrets"

- name: first line in iwd security file
  lineinfile:
    path: /var/lib/iwd/AdM13.psk
    insertbefore: BOF
    create: true
    line: "[Security]"

- name: passphrase for iwd
  lineinfile:
    path: /var/lib/iwd/AdM13.psk
    regexp: '^Passphrase='
    line: "Passphrase={{ psk }}"

- name: PreSharedKey for iwd
  lineinfile:
    path: /var/lib/iwd/AdM13.psk
    regexp: '^PreSharedKey='
    line: "PreSharedKey={{ PreSharedKey }}"

- name: /etc/ssh/known_hosts
  copy:
    content: |
      {% for i in ssh_keys.hosts %}
      {{i~' ssh-'~ssh_keys.hosts[i].type~' '~ssh_keys.hosts[i].public}}
      {{(i| split('.') | first)~' ssh-'~ssh_keys.hosts[i].type~' '~ssh_keys.hosts[i].public}}
      {% if hostvars[i].alt_names is defined %}
      # alt_names is defined
      {% for j in hostvars[i].alt_names %}
      {{j~' ssh-'~ssh_keys.hosts[i].type~' '~ssh_keys.hosts[i].public}}
      {% endfor %}
      {% endif %}
      {% endfor %}   
    dest: /etc/ssh/ssh_known_hosts

- name: ssh keys
  copy:
    content: "{{ item.content }}"
    dest: "{{ item.dest }}"
  loop:
  - content: "{{ ssh_keys.hosts[inventory_hostname].type~' '~ssh_keys.hosts[inventory_hostname].public~' root@'~inventory_hostname }}"
    dest: /etc/ssh/ssh_host_{{ ssh_keys.hosts[inventory_hostname].type }}_key.pub
  - content: "{{ ssh_keys.hosts[inventory_hostname].private}}"
    dest: /etc/ssh/ssh_host_{{ ssh_keys.hosts[inventory_hostname].type }}_key
  - content: "ssh-{{ ssh_keys.hosts[inventory_hostname].type~' '~ssh_keys.hosts[inventory_hostname].admin_pub~' root@'~inventory_hostname }}"
    dest: /root/.ssh/id_{{ ssh_keys.hosts[inventory_hostname].type }}.pub
  - content: "{{ ssh_keys.hosts[inventory_hostname].admin_key }}"
    dest: /root/.ssh/id_{{ ssh_keys.hosts[inventory_hostname].type }}

- name: authorized_keys
  copy:
    content: |
      {% for i in ssh_keys.hosts %}
      ssh-{{ ssh_keys.hosts[i].type~' '~ssh_keys.hosts[i].admin_pub~' root@'~i }}
      {% endfor %}
      {% if ssh_keys.remote_admin is defined %}
      {% for j in ssh_keys.remote_admin %}
      {{ j }}
      {% endfor %}
      {% endif %}
    dest: /root/.ssh/authorized_keys

- name: set my role_path
  set_fact:
    my_role_path: "{{ role_path }}"

- name: deploy etc from templates
  include_role:
    name: shared_helper
    tasks_from: template_directory.yaml
  vars:
    destination_dir: "/etc"
    template_source_dir: "{{ my_role_path }}/templates/etc"
    data_uuid: '{{ ansible_facts.mounts | selectattr("mount","==","/data") | map(attribute="uuid") | first | default(None) }}'

- name: ensure all filesystems are mounted
  shell: mount -a && (grep /boot /etc/fstab | grep -v ^# |  awk '{print $2}' | xargs mount)
  changed_when: false 

- name: deploy from templates to /boot
  vars:
  template:
    src: "{{ item.file }}"
    dest: "{{ item.dest }}"
    backup: "{{ item.backup | default('yes') }}"
  loop:
    - file: cmdline.txt
      dest: /boot/
      backup: no
    - file: config.txt
      dest: /boot/
      backup: no


- name: symlinks for net.lo and localtime
  file:
    src: "{{ item.src }}"
    path: "{{ item.path }}"
    owner: root
    group: root
    state: link
    force: true
  loop:
    - src: net.lo
      path: /etc/init.d/net.end0
    - src: "/usr/share/zoneinfo/{{ timezone }}"
      path: /etc/localtime

- name: cron - purge.sh
  file:
    src: /usr/local/bin/purge.sh
    dest: /etc/cron.daily/purge.sh
    state: link

- name: link deploy cron
  file:
    src: /usr/local/bin/deploy_gentoo.sh
    dest: /etc/cron.daily/deploy_gentoo.sh
    state: link
  when: alt_names is defined and alt_names.gentoo_build is defined

- name: unlink deploy cron
  file:
    dest: /etc/cron.daily/deploy_gentoo.sh
    state: absent
  when: alt_names is not defined or alt_names.gentoo_build is not defined

- name: set date if year is 1970
  shell: date +%Y | ( grep -q "^1970$" && date -s "{{ now(fmt='%Y-%m-%d %H:%M:%S') }}" ) || echo "date ok"

- name: get hostname of Ansible control node
  connection: local
  run_once: true
  delegate_to: localhost
  set_fact:
    ansible_controller_hostname: "{{ lookup('pipe', 'hostname') }}"

- name: install git directly if /var/db/repos/gentoo/.git is empty to allow emerge-sync (needed for initial installation)
  shell: |
    if [ ! -d "/var/db/repos/gentoo/.git" ]; then
      set -e
      profile_dir=/var/db/repos/gentoo/profiles
      binpkgs="/var/cache/binpkgs"
      rsync -a {{ ansible_controller_hostname }}:${profile_dir} /tmp
      mv /etc/portage/make.profile /etc/portage/make.profile.bck || true
      # see before, separate task - date -s "{{ now(fmt='%Y-%m-%d %H:%M:%S') }}" # set the time from the Control node
      ln -s /tmp/profiles/default/linux/arm64/23.0 /etc/portage/make.profile
      rsync -a {{ ansible_controller_hostname }}:${binpkgs}/Packages ${binpkgs}/Packages
      sed -i -e 's/^/#/g' /etc/portage/binrepos.conf/gentoobinhost.conf # use only self-build packages
      atoms=$(USE="adns alt-svc ftp hsts http2 http3 httpsrr imap openssl pop3 psl quic smtp ssl tftp websockets" ACCEPT_LICENSE="*" emerge --pretend --usepkg dev-vcs/git 2> /dev/null | grep "binary  N" | cut -d "]" -f 2 | cut -d " " -f 2 | sed -e 's/-[0-9].*$//g')
      atoms_iwd=$(ACCEPT_LICENSE="*" emerge -1 --usepkg --pretend net-wireless/iwd 2> /dev/null | grep "binary  N" | cut -d "]" -f 2 | cut -d " " -f 2 | sed -e "s/-[0-9].*$//g")
      for atom in ${atoms} ${atoms_iwd}; do
        pkg_dir=${binpkgs}/${atom}
        mkdir -p ${pkg_dir}
        rsync -a {{ ansible_controller_hostname }}:${pkg_dir}/* ${pkg_dir}/
        ACCEPT_LICENSE="*" emerge -1 --usepkg --nodeps ${atom}
      done
      #rsync -a {{ ansible_controller_hostname }}:/lib/modules/$(uname -r) /lib/modules/
      #rsync -a {{ ansible_controller_hostname }}:/lib/firmware /lib
      modprobe brcmfmac
      /etc/init.d/dbus start
      /etc/init.d/iwd start
      rm /etc/portage/make.profile && mv /etc/portage/make.profile.bck /etc/portage/make.profile || true
    fi

- name: emerge sync
  shell: emerge --sync
  ignore_errors: true

- name: portage profile
  shell: export LC_ALL=C && eselect profile show && eselect profile set default/linux/arm64/23.0 #/split-usr
  
- name: build and deploy
  block:
  - name: park /boot/cmdline.txt and /boot/config.txt to enable sys-boot/raspberrypi-firmware installation (breaks for hard check in ebuild)
    shell: test -f "{{ item }}" && mv "{{ item }}" "{{ item }}.deployed"
    loop:
    - /boot/cmdline.txt
    - /boot/config.txt
  
  - name: emerge build
    shell: emerge --keep-going --verbose --update --deep --newuse --with-bdeps=y @world
    when: alt_names is defined and alt_names.gentoo_build is defined and 'emerge' in ansible_run_tags

  - name: link check_and_fix.sh cron
    file:
      src: /usr/local/bin/check_and_fix.sh
      dest: /etc/cron.hourly/check_and_fix.sh
      state: link
 
  - name: emerge deploy
    shell: emerge --keep-going --verbose --update --deep --newuse --with-bdeps=y @world
    when: (alt_names is not defined or (alt_names is defined and alt_names.gentoo_build is not defined)) and 'emerge' in ansible_run_tags
  
  always:
  - name: un-park /boot/cmdline.txt and /boot/config.txt to enable sys-boot/raspberrypi-firmware installation (breaks for hard check in ebuild)
    shell: test -f "{{ item }}.deployed" && mv "{{ item }}.deployed" "{{ item }}"
    loop:
    - /boot/cmdline.txt
    - /boot/config.txt
  
- name: eclean distfiles
  shell: eclean --deep distfiles
  when: alt_names is defined and alt_names.gentoo_build is defined and 'emerge' in ansible_run_tags
 
- name: eclean packages
  shell: eclean --deep packages

- name: emerge depclean
  shell: emerge --depclean

- name: emerge preserved rebuild
  shell: emerge @preserved-rebuild
  when: alt_names is defined and alt_names.gentoo_build is defined and 'emerge' in ansible_run_tags

- name: emerge preserved rebuild
  shell: emerge @preserved-rebuild
  when: alt_names is defined and alt_names.gentoo_build is not defined and 'emerge' in ansible_run_tags

- name: install additional modules from Ansible Galaxy
  shell: ansible-galaxy collection install gluster.gluster --upgrade #--collections-path /usr/lib/python3.12/site-packages/ansible_collections

#- name: disable services
#  service:
#    name: "{{ item }}"
#    enabled: no
#    state: stopped
#  loop:

- name: enable keepalive only on control_plane nodes 
  service:
    name: "{{ item }}"
    enabled: yes
    state: reloaded
  loop:
    - keepalived
  when: inventory_hostname in (groups['all'] | map('extract', hostvars) | selectattr('system_roles', 'defined') | selectattr('system_roles', 'contains', 'control_plane') | map(attribute='inventory_hostname') )

- name: only enable and reload services, but don't force a restart 
  service:
    name: "{{ item }}"
    enabled: yes
    state: reloaded
  loop:
    - autofs
    - sshd
    - haproxy
    - crio
    - syslog-ng

- name: enable and restart services
  service:
    name: "{{ item }}"
    enabled: yes
    state: restarted
  loop:
    - net.end0
    - chronyd
    - brickmount
    - glusterd 
    - cronie
    - cpupower
    - iscsid
    - iwd
  ignore_errors: yes

- name: gluster
  import_tasks: gluster.yml
  
- name: put certificates and keys in place
  copy:
    content: "{{ lookup('file', cert_path~'/FreeAsABird/subject_keys/'~item.name~'.pem') }}\n{{ lookup('file', cert_path~'/FreeAsABird/certs/'~item.name~'.crt') }}"
    dest: "{{ item.dest }}/{{ item.name }}.pem"
  loop: "{{ certs }}"
  throttle: 1
    
- name: put certificate keys in place
  copy:
    src: "{{ cert_path }}/FreeAsABird/subject_keys/{{ item.name }}.pem"
    dest: "{{ item.dest }}/{{ item.name }}.key"
  loop: "{{ certs }}"
  throttle: 1
    
- name: put certificates in place
  copy:
    src: "{{ cert_path }}/FreeAsABird/certs/{{ item.name }}.crt"
    dest: "{{ item.dest }}/{{ item.name }}.crt"
  loop: "{{ certs }}"
  throttle: 1

