---
- name: get seed
  shell: echo $RANDOM
  run_once: true
  register: seed
  
- set_fact:
    selected_host: "{{ ansible_play_hosts | random(seed=seed.stdout) }}"

- debug: 
    msg: "selected_host:{{ selected_host }}"


- name: system configurations
  import_tasks: system.yml

- name: force-reinstall
  shell: /etc/init.d/kubelet stop; kubeadm reset --force; rm -rf kubeadm.log /etc/kubernetes/pki/ /etc/kubernetes/manifests/ /etc/kubernetes/tmp/ /etc/kubernetes/*.conf  /var/log/kubelet/kubelet.log /var/log/crio/crio.log /var/lib/kubelet/*; iptables -F; iptables -t nat -F; /etc/init.d/crio restart; ip link delete dev cni0; ip link delete dev flannel.1; rm  /opt/cni/bin/flannel /etc/cni/net.d/10-flannel.conflist; /etc/init.d/kubelet restart
  ignore_errors: yes
  when: "'force_reinstall' in ansible_run_tags" 
  tags:
    - never
    - force_reinstall

- name: check kubernetes status
  import_tasks: k8s-status.yml

- name: prepare images
  import_tasks: prepare_images.yml
  delegate_to: "{{ selected_host }}"
  run_once: true
  tags:
  - k8s_images

- name: install cluster if needed
  include_tasks: init.yml
  when: not etc_k8s.stat.exists and inventory_hostname == selected_host

- name: install flannel pod network
  shell: |
    . set_env.sh kube-flannel
    kubectl get ns kube-flannel 2>/dev/null > /dev/null || kubectl create ns kube-flannel
    kubectl label --overwrite ns kube-flannel pod-security.kubernetes.io/enforce=privileged
    helm upgrade --reset-values --install -n kube-flannel kube-flannel kube-flannel/flannel --set 'flannel.args={--iface=end0,--ip-masq,--kube-subnet-mgr}'  
  # when: not etc_k8s.stat.exists and inventory_hostname == selected_host
  when: inventory_hostname == selected_host

- name: join nodes if needed
  include_tasks: join.yml
  when: not etc_k8s.stat.exists and inventory_hostname != selected_host

- name: taint to allow master nodes to run pods
  shell: |
    kubectl get node -o custom-columns=NAME:.metadata.name,TAINT:.spec.taints[*].effect | grep -e master:NoSchedule >/dev/null && kubectl taint nodes --all node-role.kubernetes.io/master:NoSchedule-
    kubectl get node -o custom-columns=NAME:.metadata.name,TAINT:.spec.taints[*].effect | grep -e control-plane:NoSchedule >/dev/null && kubectl taint nodes --all node-role.kubernetes.io/control-plane:NoSchedule-
    true
  when: inventory_hostname == selected_host

# update if version is newer 
- name: get k8s version
  shell: "grep image: {{ k8s_check_file }} | cut -d : -f 4"
  register: current_k8s_version
  
- debug:
    msg: "installed k8s version: {{ current_k8s_version }}"
  
- debug: 
    msg: update
  when: current_k8s_version.stdout is version( k8s_version, '<')
- block:
  - name: scale down application deployments
    shell: |
      for ns in $(kubectl get ns  | grep -v -e ^NAME -e ^kube | awk '{print $1}'); do echo "namespace: $ns";for x in $(kubectl get deploy -n $ns | grep -v NAME | awk '{print $1}'); do kubectl scale --replicas=0 deploy -n $ns $x ; done; done
  - name: update k8s without etcd
    shell: "KUBECONFIG=/etc/kubernetes/admin.conf kubeadm upgrade apply --etcd-upgrade=false --yes {{ k8s_version }}"
    throttle: 1
  - name: update etcd
    shell: "KUBECONFIG=/etc/kubernetes/admin.conf kubeadm upgrade apply --etcd-upgrade=true --yes {{ k8s_version }}"
    throttle: 1
  - name: scale up application deployments
    shell: |
      for ns in $(kubectl get ns  | grep -v -e ^NAME -e ^kube | awk '{print $1}'); do echo "namespace: $ns";for x in $(kubectl get deploy -n $ns | grep -v NAME | awk '{print $1}'); do kubectl scale --replicas=1 deploy -n $ns $x ; done; done
  when: current_k8s_version.stdout is version( k8s_version, '<')

- name: ca template
  template:
    src: ca
    dest: /tmp/myca

- name: create CA configmap
  shell: |
    kubectl apply -f /tmp/myca

- block:
  - name: coredns configmap template
    template:
      src: coredns.cm.yaml
      dest: /tmp/coredns.cm.yaml
    #with_items: "{{ gateways }}"

  - name: additional DNS entries and external CoreDNS IP
    shell: |
      # kubectl get -o yaml cm coredns -n kube-system  | sed -e '/hosts/,/}/d'| sed -e 's/^\(\s*\)\(errors\)\s*$/\1\2\n\1hosts {\n\1  192.168.4.100 my-lb.adm13\n\1    fallthrough\n\1}/g' | kubectl replace -f -
      kubectl replace -f /tmp/coredns.cm.yaml
      kubectl patch svc --namespace kube-system kube-dns --patch '{"spec": { "externalIPs": ["{{ external_coredns_ip }}"] }}'
  run_once: true
     
